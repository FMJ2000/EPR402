
beginsymbol(dot_size# + 2side_bearing#, vcentre(2dot_size#)); "centre dot";
  pickup rule_pen;

  fill circle((w/2, (h-d)/2), dot_size);
endchar;

for alpha = 0, 90, 45, 135:
  beginarrow(alpha, (3dot_size# + equal_spread#)/arrow_horiz_len#, dot_size#);
    "colon (" & decimal alpha & ")";
    pickup rule_pen;

    z1 - z0 = (2dot_size + equal_spread) * dir alpha;
    1/2[z0,z1] = centre;

    fill circle(z0, dot_size);
    fill circle(z1, dot_size);
  endchar;
endfor;

for alpha = 0, 90, 45, 135:
  beginarrow(alpha, (5dot_size# + 2equal_spread#)/arrow_horiz_len#, dot_size#);
    "triple colon (" & decimal alpha & ")";
    pickup rule_pen;

    z1 - z0 = (2dot_size + equal_spread) * dir alpha;
    z2 - z1 = (2dot_size + equal_spread) * dir alpha;
    z1      = centre;

    fill circle(z0, dot_size);
    fill circle(z1, dot_size);
    fill circle(z2, dot_size);
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(plus_size#, 1); "therefore (" & decimal alpha & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;
    r := r * 1/3[1, sqrt 2];

    fill circle(centre + r * dir alpha,         dot_size);
    fill circle(centre + r * dir (alpha + 120), dot_size);
    fill circle(centre + r * dir (alpha + 240), dot_size);
  endchar;
endfor;

for alpha = 0, 45:
  beginoperator(plus_size#, 1); "quad dot (" & decimal alpha & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;
    r := r * 1/3[1, sqrt 2];

    fill circle(centre + r * dir alpha,         dot_size);
    fill circle(centre + r * dir (alpha +  90), dot_size);
    fill circle(centre + r * dir (alpha + 180), dot_size);
    fill circle(centre + r * dir (alpha + 270), dot_size);
  endchar;
endfor;

beginoperator(plus_size#, 1); "five dots";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;
  r := r * 1/3[1, sqrt 2];

  fill circle(centre, dot_size);
  fill circle(centre + r * dir   0, dot_size);
  fill circle(centre + r * dir  90, dot_size);
  fill circle(centre + r * dir 180, dot_size);
  fill circle(centre + r * dir 270, dot_size);
endchar;

beginoperator(plus_size#, 1); "minus";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 0) -- (centre + r * dir 180);
endchar;

beginoperator(plus_size#, 1); "bar";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 90) -- (centre + r * dir 270);
endchar;

beginoperator(plus_size#, 1); "medium slash";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;
  r := r * 1/3[1, sqrt 2];

  draw (centre + r * dir  45) -- (centre + r * dir 225);
endchar;

beginoperator(plus_size#, 1); "medium backslash";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;
  r := r * 1/3[1, sqrt 2];

  draw (centre + r * dir 135) -- (centre + r * dir 315);
endchar;

beginoperator(plus_size#, 1); "plus";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir  0) -- (centre + r * dir 180);
  draw (centre + r * dir 90) -- (centre + r * dir 270);
endchar;

beginoperator(plus_size#, 1); "times";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;
  r := r * 1/3[1, sqrt 2];

  draw (centre + r * dir  45) -- (centre + r * dir 225);
  draw (centre + r * dir 135) -- (centre + r * dir 315);
endchar;

beginoperator(plus_size#, 1); "plus minus";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir  0) -- (centre + r * dir 180);
  draw (centre + r * dir 90) -- (centre + (r - 1/4rule_thickness) * dir 270);

  draw (centre + r * (dir 0 - dir 90)) -- (centre + r * (dir 180 - dir 90));
endchar;

beginoperator(plus_size#, 1); "minus plus";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir  0)                       -- (centre + r * dir 180);
  draw (centre + (r - 1/4rule_thickness) * dir 90) -- (centre + r * dir 270);

  draw (centre + r * (dir 0 + dir 90)) -- (centre + r * (dir 180 + dir 90));
endchar;

for angle = 0, 90, 180, 270:
  beginoperator(plus_size#, 1); "dot minus (" & decimal angle & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;

    draw (centre - r * dir angle) -- (centre + r * dir angle);
    fill circle(centre + equal_spread * dir (angle + 90), dot_size);
  endchar;
endfor;

for angle = 0, 45, 90, 135:
  beginoperator(plus_size#, 1); "divides";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;

    draw (centre - r * dir angle) -- (centre + r * dir angle);
    fill circle(centre + equal_spread * dir (angle + 90), dot_size);
    fill circle(centre - equal_spread * dir (angle + 90), dot_size);
  endchar;
endfor;

% Warning: The other two orientations are below.
% They should stay consistent.

beginoperator(plus_size#, 1); "logical not";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 180) -- (centre + r * dir 0)
                              -- (centre + r * dir 0 - equal_spread * dir 90);
endchar;

beginoperator(plus_size#, 1); "reversed logical not";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 180 - equal_spread * dir 90)
    -- (centre + r * dir 180) -- (centre + r * dir 0)
endchar;

for alpha = 0, 90, 180, 270:
  beginoperator(plus_size#, 1); "times (" & decimal alpha & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;
    r := r * 1/3[1, sqrt 2];

    draw (centre + r * dir (alpha +  45)) -- (centre + r * dir (alpha + 225)) --
         (centre + r * dir (alpha + 315)) -- (centre + r * dir (alpha + 135));
  endchar;
endfor;

for alpha = 0, 90:
  beginoperator(plus_size#, 1); "bowtie (" & decimal alpha & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;
    r := r * 1/3[1, sqrt 2];

    draw (centre + r * dir (alpha +  45)) -- (centre + r * dir (alpha + 225)) --
         (centre + r * dir (alpha + 135)) -- (centre + r * dir (alpha + 315)) -- cycle;
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(plus_size#, 1); "Y (" & decimal alpha & ")";
    pickup rule_pen;

    r := plus_size/2; % - 11/10rule_thickness;
    r := r * 1/3[1, sqrt 2];

    draw centre -- (centre + r * dir alpha);
    draw centre -- (centre + r * dir (alpha + 120));
    draw centre -- (centre + r * dir (alpha + 240));
  endchar;
endfor;

% operators

for sign = 1, -1:
  beginoperator(plus_size#, 1); "wedge";
    pickup rule_pen;

    z2 - z0 = plus_size * dir 0;

    x1 = 1/2[x0, x2] = w/2;

    y1 - y0 = sign * plus_size;
    1/2[y0,y1] = ypart centre;

    draw z0 -- z1 -- z2;
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "wedge dot";
    pickup rule_pen;

    z2 - z0 = plus_size * dir 0;

    x1 = 1/2[x0, x2] = w/2;

    y1 - y0 = sign * plus_size;
    1/2[y0,y1] = ypart centre;

    draw z0 -- z1 -- z2;
    fill circle(centre - sign * 1/3plus_size * dir 90, dot_size);
  endchar;
endfor;

for sign = 1, -1:
  beginsymbol(13/9plus_size# + 2side_bearing#, vcentre(plus_size# + rule_thickness#));
    "double wedge";

    pickup rule_pen;

    z2 - z0 = plus_size * dir 0;

    x1 = 1/2[x0, x2] = w/2;

    y1 - y0 = sign * plus_size;
    1/2[y0,y1] = ypart centre;

    1/2[z0a,z0b] = z0;
    1/2[z1a,z1b] = z1;
    1/2[z2a,z2b] = z2;
    z0b - z0a = z1b - z1a = z2b - z2a = 4/9plus_size * dir 0;

    draw z0a -- z1a -- z2a;
    draw z0b -- z1b -- z2b;
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "curly wedge";
    pickup rule_pen;

    draw prec(centre + sign * 1/2plus_size * dir 90,
              centre - sign * 1/2plus_size * dir 90,
              plus_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "curly wedge dot";
    pickup rule_pen;

    draw prec(centre + sign * 1/2plus_size * dir 90,
              centre - sign * 1/2plus_size * dir 90,
              plus_size);
    fill circle(centre - sign * 5/12plus_size * dir 90, dot_size);
  endchar;
endfor;

for sign = 1, -1:
  beginsymbol(13/9plus_size# + 2side_bearing#, vcentre(plus_size# + rule_thickness#));
    "double wedge";

    pickup rule_pen;

    1/2[z0,z1] = (w/2, (h-d)/2);
    z1 - z0 = 4/9plus_size * dir 0;

    draw prec(z0 + sign * 1/2plus_size * dir 90,
              z0 - sign * 1/2plus_size * dir 90,
              plus_size);
    draw prec(z1 + sign * 1/2plus_size * dir 90,
              z1 - sign * 1/2plus_size * dir 90,
              plus_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "union";
    pickup rule_pen;

    draw subset(centre - sign * 1/2plus_size * dir 90,
                centre + sign * 1/2plus_size * dir 90,
                plus_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(4/3plus_size#, 1); "double union";
    pickup rule_pen;

    draw subset(centre - sign * 5/18plus_size * dir 90,
                centre + sign * 2/3plus_size * dir 90,
                5/9plus_size);
    draw subset(centre - sign * 2/3plus_size * dir 90,
                centre + sign * 2/3plus_size * dir 90,
                4/3plus_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "union dot";
    pickup rule_pen;

    draw subset(centre - sign * 1/2plus_size * dir 90,
                centre + sign * 1/2plus_size * dir 90,
                plus_size);
    fill circle(centre + sign * 1/6plus_size * dir 90, dot_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "union plus";
    pickup rule_pen;

    draw subset(centre - sign * 1/2plus_size * dir 90,
                centre + sign * 1/2plus_size * dir 90,
                plus_size);

    t := 22/10rule_thickness;
    r := 1/2plus_size - t;

    draw (centre + sign * 1/6plus_size * dir 90 + r * dir  0)
      -- (centre + sign * 1/6plus_size * dir 90 + r * dir 180);
    draw (centre + (r + sign * 1/6plus_size) * dir 90)
      -- (centre + (r - sign * 1/6plus_size) * dir 270);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "square union";
    pickup rule_pen;

    z3 - z0 = z2 - z1 = plus_size * dir 0;
    z0 - z1 = sign * plus_size * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z0 -- z1 -- z2 -- z3;
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(4/3plus_size#, 1); "double square union";
    pickup rule_pen;

    z3a - z0a = z2a - z1a = 4/3plus_size * dir 0;
    z0a - z1a = sign * 4/3plus_size * dir 90;

    1/2[1/2[z0a,z1a], 1/2[z2a,z3a]] = centre;

    z3b - z0b = z2b - z1b = 5/9plus_size * dir 0;
    z0b - z1b = sign * 17/18plus_size * dir 90;

    y0b = y0a;
    1/2[x0b, x3b] = xpart centre;

    draw z0a -- z1a -- z2a -- z3a;
    draw z0b -- z1b -- z2b -- z3b;
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "square union dot";
    pickup rule_pen;

    z3 - z0 = z2 - z1 = plus_size * dir 0;
    z0 - z1 = sign * plus_size * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z0 -- z1 -- z2 -- z3;

    fill circle(centre + sign * 1/6plus_size * dir 90, dot_size);
  endchar;
endfor;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "square union plus";
    pickup rule_pen;

    z3 - z0 = z2 - z1 = plus_size * dir 0;
    z0 - z1 = sign * plus_size * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z0 -- z1 -- z2 -- z3;

    t := 22/10rule_thickness;
    r := 1/2plus_size - t;

    draw (centre + sign * 1/6plus_size * dir 90 + r * dir  0)
      -- (centre + sign * 1/6plus_size * dir 90 + r * dir 180);
    draw (centre + (r + sign * 1/6plus_size) * dir 90)
      -- (centre + (r - sign * 1/6plus_size) * dir 270);
  endchar;
endfor;


% triangles

for alpha = 0, 90, 180, 270:
  beginoperator(small_op_size#, 1); "small triangle (" & decimal alpha & ")";
    pickup rule_pen;
    draw triangle(centre, w/2-side_bearing, alpha);
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(small_op_size#, 1); "small filled triangle (" & decimal alpha & ")";
    pickup rule_pen;
    draw triangle(centre, w/2-side_bearing, alpha);
    fill triangle(centre, w/2-side_bearing, alpha);
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(med_op_size#, 1); "medium triangle (" & decimal alpha & ")";
    pickup rule_pen;
    draw triangle(centre, w/2-side_bearing, alpha);
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(large_op_size#, 1); "large triangle (" & decimal alpha & ")";
    pickup rule_pen;
    draw triangle(centre, w/2-side_bearing, alpha);
  endchar;
endfor;

% circles

beginoperator(4/5small_op_size#, 1); "small circle";
  pickup rule_pen;
  draw circle(centre, 4/10small_op_size);
endchar;

beginoperator(4/5small_op_size#, 1); "small filled circle";
  pickup rule_pen;
  draw circle(centre, 4/10small_op_size);
  fill circle(centre, 4/10small_op_size);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle";
  pickup rule_pen;
  draw circle(centre, plus_size/2 + 11/10rule_thickness);
endchar;

beginoperator(4/5large_op_size#, 1); "large circle";
  pickup rule_pen;
  draw circle(centre, 4/10large_op_size);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle minus";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * left) -- (centre + plus_size/2 * right);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle bar";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * up) -- (centre + plus_size/2 * down);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle slash";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * dir  45) -- (centre + plus_size/2 * dir 225);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle backslash";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * dir 135) -- (centre + plus_size/2 * dir 315);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle plus";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * left) -- (centre + plus_size/2 * right);
  draw (centre + plus_size/2 * up)   -- (centre + plus_size/2 * down);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle times";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + plus_size/2 * dir  45) -- (centre + plus_size/2 * dir 225);
  draw (centre + plus_size/2 * dir 135) -- (centre + plus_size/2 * dir 315);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle dot";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  fill circle(centre, 1.3dot_size);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle circle";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw circle(centre, (plus_size + 11/5rule_thickness)/5);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle triangle";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw triangle(centre, small_op_size/2, 90);
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle asterisk";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);

  penpos a0(4/3rule_thickness,   0 - 7);
  penpos a1(4/3rule_thickness,  72 - 7);
  penpos a2(4/3rule_thickness, 144 - 7);
  penpos a3(4/3rule_thickness, 216 - 7);
  penpos a4(4/3rule_thickness, 288 - 7);

  penpos b0(2/3rule_thickness,   0 - 7);
  penpos b1(2/3rule_thickness,  72 - 7);
  penpos b2(2/3rule_thickness, 144 - 7);
  penpos b3(2/3rule_thickness, 216 - 7);
  penpos b4(2/3rule_thickness, 288 - 7);

  reg_poly_points(a)(5, centre, plus_size/2, 77);

  z.b0 = z.b1 = z.b2 = z.b3 = z.b4 = centre;

  fill stroke z.a0e -- z.b0e;
  fill stroke z.a1e -- z.b1e;
  fill stroke z.a2e -- z.b2e;
  fill stroke z.a3e -- z.b3e;
  fill stroke z.a4e -- z.b4e;
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "medium circle star";
  pickup rule_pen;

  draw circle(centre, plus_size/2 + 11/10rule_thickness);

  reg_poly_points(a)(5, centre, plus_size/2, 90);
  reg_poly_points(b)(5, centre, plus_size/20, 126);

  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
  fill z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;

beginoperator(plus_size# + 11/5rule_thickness#, 1); "negated medium circle";
  pickup rule_pen;

  r := 3/4(plus_size + 11/5rule_thickness);

  draw circle(centre, plus_size/2 + 11/10rule_thickness);
  draw (centre + r * dir 45) -- (centre + r * dir 225);
endchar;

% squares

beginoperator(small_op_size#/sqrt(2), 1); "small square";
  pickup rule_pen;
  draw square(centre, w/2 - side_bearing, 0);
endchar;
beginoperator(small_op_size#/sqrt(2), 1); "small filled square";
  pickup rule_pen;
  draw square(centre, w/2 - side_bearing, 0);
  fill square(centre, w/2 - side_bearing, 0);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square";
  pickup rule_pen;
  draw square(centre, w/2 - side_bearing, 0);
endchar;
beginoperator(large_op_size#/sqrt(2), 1); "large square";
  pickup rule_pen;
  draw square(centre, w/2 - side_bearing, 0);
endchar;

beginoperator(small_op_size#, 1); "small diamond";
  pickup rule_pen;
  draw square(centre, (w/2 - side_bearing) / sqrt(2), 45);
endchar;
beginoperator(small_op_size#, 1); "small filled diamond";
  pickup rule_pen;
  draw square(centre, (w/2 - side_bearing) / sqrt(2), 45);
  fill square(centre, (w/2 - side_bearing) / sqrt(2), 45);
endchar;
beginoperator(med_op_size#, 1); "medium diamond";
  pickup rule_pen;
  draw square(centre, (w/2 - side_bearing) / sqrt(2), 45);
endchar;
beginoperator(large_op_size#, 1); "large diamond";
  pickup rule_pen;
  draw square(centre, (w/2 - side_bearing) / sqrt(2), 45);
endchar;

beginoperator(med_op_size#/sqrt(2), 1); "medium square minus";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + sqrt .5 * r * dir  0) -- (centre + sqrt .5 * r * dir 180);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square vert";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + sqrt .5 * r * dir 90) -- (centre + sqrt .5 * r * dir 270);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square slash";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + r * dir 45) -- (centre + r * dir 225);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square backslash";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + r * dir 135) -- (centre + r * dir 315);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square plus";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + sqrt .5 * r * dir  0) -- (centre + sqrt .5 * r * dir 180);
  draw (centre + sqrt .5 * r * dir 90) -- (centre + sqrt .5 * r * dir 270);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square times";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw (centre + r * dir  45) -- (centre + r * dir 225);
  draw (centre + r * dir 135) -- (centre + r * dir 315);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square dot";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  fill circle(centre, 1.3dot_size);
endchar;
beginoperator(med_op_size#/sqrt(2), 1); "medium square square";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r, 0);
  draw square(centre, .4r, 0);
endchar;

beginoperator(med_op_size#, 1); "medium diamond minus";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + r * dir  0) -- (centre + r * dir 180);
endchar;
beginoperator(med_op_size#, 1); "medium diamond vert";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + r * dir 90) -- (centre + r * dir 270);
endchar;
beginoperator(med_op_size#, 1); "medium diamond slash";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + sqrt .5 * r * dir 45) -- (centre + sqrt .5 * r * dir 225);
endchar;
beginoperator(med_op_size#, 1); "medium diamond backslash";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + sqrt .5 * r * dir 135) -- (centre + sqrt .5 * r * dir 315);
endchar;
beginoperator(med_op_size#, 1); "medium diamond plus";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + r * dir  0) -- (centre + r * dir 180);
  draw (centre + r * dir 90) -- (centre + r * dir 270);
endchar;
beginoperator(med_op_size#, 1); "medium diamond times";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw (centre + sqrt .5 * r * dir  45) -- (centre + sqrt .5 * r * dir 225);
  draw (centre + sqrt .5 * r * dir 135) -- (centre + sqrt .5 * r * dir 315);
endchar;
beginoperator(med_op_size#, 1); "medium diamond dot";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  fill circle(centre, 1.3dot_size);
endchar;
beginoperator(med_op_size#, 1); "medium diamond diamond";
  pickup rule_pen;
  r := w/2 - side_bearing;
  draw square(centre, r / sqrt(2), 45);
  draw square(centre, .4r, 45);
endchar;

beginoperator(small_op_size#, 1); "small star";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .4r, 126);
  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;
beginoperator(small_op_size#, 1); "small filled star";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .4r, 126);
  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
  fill z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;
beginoperator(med_op_size#, 1); "medium star";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .4r, 126);
  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;
beginoperator(large_op_size#, 1); "large star";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .4r, 126);
  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;
beginoperator(med_op_size#, 1); "medium pentagram";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  draw z.a0 -- z.a2 -- z.a4 -- z.a1 -- z.a3 -- cycle;
endchar;
beginoperator(large_op_size#, 1); "large pentagram";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  draw z.a0 -- z.a2 -- z.a4 -- z.a1 -- z.a3 -- cycle;
endchar;

beginoperator(small_op_size#, 1); "medium thin filled star";
  pickup pencircle scaled 1/2rule_thickness;

  r := w/2 - side_bearing;

  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .2r, 126);

  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
  fill z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;

beginoperator(small_op_size#, 1); "asterisk";
  r := w/2 - side_bearing;

  penpos a0(4/3rule_thickness,   0 - 7);
  penpos a1(4/3rule_thickness,  72 - 7);
  penpos a2(4/3rule_thickness, 144 - 7);
  penpos a3(4/3rule_thickness, 216 - 7);
  penpos a4(4/3rule_thickness, 288 - 7);

  penpos b0(2/3rule_thickness,   0 - 7);
  penpos b1(2/3rule_thickness,  72 - 7);
  penpos b2(2/3rule_thickness, 144 - 7);
  penpos b3(2/3rule_thickness, 216 - 7);
  penpos b4(2/3rule_thickness, 288 - 7);

  reg_poly_points(a)(5, centre, r, 77);

  z.b0 = z.b1 = z.b2 = z.b3 = z.b4 = centre;

  fill stroke z.a0e -- z.b0e;
  fill stroke z.a1e -- z.b1e;
  fill stroke z.a2e -- z.b2e;
  fill stroke z.a3e -- z.b3e;
  fill stroke z.a4e -- z.b4e;
endchar;

for alpha = 0, 45, 90, 135:
  beginsymbol(2order_width# * abs (cosd (alpha)) + 5/3equal_spread# * abs (sind (alpha)) + 2side_bearing#,
      vcentre(2order_width# * abs (sind (alpha)) + 5/3equal_spread# * abs (cosd (alpha)) + rule_thickness#));
    "infinity";
    pickup rule_pen;

    pair centre;
    centre := (w/2, (h-d)/2);

    z0 = centre - (order_width - 1/2rule_thickness) * dir alpha;
    z1 = centre + (order_width - 1/2rule_thickness) * dir alpha;

    z6 = 1/5[z0,z1];
    z7 = 4/5[z0,z1];

    z2 = z6 + 5/6equal_spread * dir (alpha + 90);
    z3 = z6 - 5/6equal_spread * dir (alpha + 90);
    z4 = z7 + 5/6equal_spread * dir (alpha + 90);
    z5 = z7 - 5/6equal_spread * dir (alpha + 90);

    draw z4{dir (alpha + 180)}
      .. {dir (alpha + 225)}1/2[z0,z1]{dir (alpha + 225)}
      .. {dir (alpha + 180)}z3{dir (alpha + 180)}
      .. {dir (alpha + 90)}z0{dir (alpha + 90)}
      .. {dir (alpha + 0)}z2{dir (alpha + 0)}
      .. {dir (alpha + -45)}1/2[z0,z1]{dir (alpha + -45)}
      .. {dir (alpha + 0)}z5{dir (alpha + 0)}
      .. {dir (alpha + 90)}z1{dir (alpha + 90)}
      .. cycle;
    labels (0,1,2,3,4,5,6,7);
  endchar;
endfor

for alpha = 0, 90, 180, 270:
  beginsymbol(17/10order_width# * abs (cosd (alpha)) + 5/3equal_spread# * abs (sind (alpha)) + 2side_bearing#,
      vcentre(17/10order_width# * abs (sind (alpha)) + 5/3equal_spread# * abs (cosd (alpha)) + rule_thickness#));
    "proportional";
    pickup rule_pen;

    pair centre;
    centre := (w/2, (h-d)/2);

    z0 = centre - (17/20order_width - 1/2rule_thickness) * dir alpha;
    z1 = centre + (15/20order_width - 1/2rule_thickness) * dir alpha;

    z4 = z1 + 5/6equal_spread * dir (alpha + 90);
    z5 = z1 - 5/6equal_spread * dir (alpha + 90);

    z6 - z4 = z7 - z5 = 1/10order_width * dir alpha;

    z8 = 1/4[z0,z1];

    z2 = z8 + 5/6equal_spread * dir (alpha + 90);
    z3 = z8 - 5/6equal_spread * dir (alpha + 90);

    draw z6 -- z4{dir (alpha + 180)}
            .. {dir (alpha + 225)}5/8[z0,z1]{dir (alpha + 225)}
            .. {dir (alpha + 180)}z3{dir (alpha + 180)}
            .. {dir (alpha + 90)}z0{dir (alpha + 90)}
            .. {dir (alpha + 0)}z2{dir (alpha + 0)}
            .. {dir (alpha + -45)}5/8[z0,z1]{dir (alpha + -45)}
            .. {dir (alpha + 0)}z5 -- z7;
    labels (0,1,2,3,4,5,6,7);
  endchar;
endfor;

for alpha = 0, 45, 90, 135:
  beginsymbol(14/10order_width# * abs (cosd (alpha)) + 5/3equal_spread# * abs (sind (alpha)) + 2side_bearing#,
      vcentre(14/10order_width# * abs (sind (alpha)) + 5/3equal_spread# * abs (cosd (alpha)) + rule_thickness#));
    "crossing";
    pickup rule_pen;

    pair centre;
    centre := (w/2, (h-d)/2);

    z0 = centre - (14/20order_width - 1/2rule_thickness) * dir alpha;
    z1 = centre + (14/20order_width - 1/2rule_thickness) * dir alpha;

    z2 = z0 + 5/6equal_spread * dir (alpha + 90);
    z3 = z0 - 5/6equal_spread * dir (alpha + 90);
    z4 = z1 + 5/6equal_spread * dir (alpha + 90);
    z5 = z1 - 5/6equal_spread * dir (alpha + 90);

    z6 - z4 = z7 - z5 = 1/10order_width * dir alpha;
    z2 - z8 = z3 - z9 = 1/10order_width * dir alpha;

    draw z6 -- z4{dir (alpha + 180)}
            .. {dir (alpha + 225)}1/2[z0,z1]{dir (alpha + 225)}
            .. {dir (alpha + 180)}z3 -- z9;
    draw z8 -- z2{dir (alpha + 0)}
            .. {dir (alpha + -45)}1/2[z0,z1]{dir (alpha + -45)}
            .. {dir (alpha + 0)}z5 -- z7;
    labels (0,1,2,3,4,5,6,7,8,9);
  endchar;
endfor;

beginoperator(med_op_size#, 1); "between";
  pickup rule_pen;

  r := w/2 - side_bearing;

  draw smile( 1, centre - r * dir 90, centre + r * dir 90, equal_spread, true);
  draw smile(-1, centre - r * dir 90, centre + r * dir 90, equal_spread, true);
endchar;

beginoperator(med_op_size#, 1); "reversed between";
  pickup rule_pen;

  r := w/2 - side_bearing;

  draw smile( 1,  centre - 2/3equal_spread * dir 0 - r * dir 90,
                  centre - 2/3equal_spread * dir 0 + r * dir 90,
                  2/3equal_spread, true);
  draw smile(-1, centre + 2/3equal_spread * dir 0 - r * dir 90,
                 centre + 2/3equal_spread * dir 0 + r * dir 90,
                 2/3equal_spread, true);
endchar;

for sign = 1, -1:
  beginsymbol(order_width# + 2side_bearing#, 2math_axis# + rule_thickness#, rule_thickness#); "top";
    pickup rule_pen;

    z1 - z0 = z3 - z2 = order_width * dir 0;
    z2 - z0 = sign * 2math_axis * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = (w/2, (h-d)/2);

    draw z0 -- z1;
    draw 1/2[z0,z1] -- 1/2[z2,z3];
  endchar;
endfor;

beginsymbol(2/3equal_spread# + 2side_bearing#, vcentre(plus_size#+rule_thickness#)); "wreath";
  pickup rule_pen;

  z0 = (w/2, (h-d)/2);

  draw sim(z0 + 1/2plus_size * dir 90, z0 - 1/2plus_size * dir 90);
endchar;

beginoperator(med_op_size#, 1); "angle";
  pickup rule_pen;

  z0 = centre - 1/3plus_size * dir 90;

  z1 = z0 + 1/2plus_size * dir 0;
  z2 = z0 - 1/2plus_size * dir 0;
  x3 = xpart centre + 1/2plus_size;
  y3 = ypart centre + 2/3plus_size;

  draw z1 -- z2 -- 5/6[z2,z3];
endchar;

beginoperator(med_op_size#, 1); "measured angle";
  pickup rule_pen;

  z0 = centre - 1/3plus_size * dir 90;

  z1 = z0 + 1/2plus_size * dir 0;
  z2 = z0 - 1/2plus_size * dir 0;
  x3 = xpart centre + 1/2plus_size;
  y3 = ypart centre + 2/3plus_size;

  z4 = 2/3 [z2,z1];
  z5 = z2 + (z4 - z2) rotated angle (z3 - z2);

  draw z1 -- z2 -- 5/6[z2,z3];
  draw z4{dir 90} .. {dir (angle (z3 - z2) + 90)}z5;
endchar;

beginoperator(med_op_size#, 1); "spherical angle";
  pickup rule_pen;

  z0 = centre - 1/2plus_size * dir 0;

  z1 = z0 + plus_size * dir 25;
  z2 = z0 + plus_size * dir -25;
  z3 = z0 + 2/3plus_size * dir 25;
  z4 = z0 + 2/3plus_size * dir -25;

  draw z1 -- z0 -- z2;
  draw z4{dir 65} .. {dir 115}z3;
endchar;

beginsymbol(5.5u#, 4/5asc_height#, 0); "prime";
  pickup penrazor;

  z0 = (w, h);

  z1 = z0 + 7/3u * dir 183;

  z2 = (1u, 1/9h);
  z3 = z2 + u * dir -20;

  fill z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

beginsymbol(5.5u#, 4/5asc_height#, 0); "backprime";
  pickup penrazor;

  z0 = (0, h);

  z1 = z0 + 7/3u * dir -3;

  z2 = (w - 1u, 1/9h);
  z3 = z2 + u * dir 200;

  fill z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "product";
    draw_product(centre, plus_size, plus_size, sign, rule_thickness);
  endchar;
endfor;

beginsymbol(13u# + 2side_bearing#, asc_height#, 0); "check mark";
  pickup pencircle
    xscaled 3/2rule_thickness
    yscaled 3/4rule_thickness
    rotated 30;

  lft x1 = hround(1.5u);
  x2 = hround(w/3);
  x3 = w - x1;
  x4 = w - 3/2x2;

  y1 = math_axis;
  y2 = -d;
  y3 = y4 = h;

  draw z1 -- z2{z4 - z2} .. z3;

  penlabels(1,2,3,4);
endchar; 

beginsymbol(6u# + 2side_bearing#, 5/4asc_height#, 1/8asc_height#); "lightning";

  penpos1 (2rule_thickness, -20);
  penpos4 (5/6rule_thickness, -20);

  x3r = w - side_bearing;
  x2l = side_bearing;
  x4  = 1/4w;

  y1l = h;
  y3r = 14/24h;
  y4  = -d + 1/2rule_thickness;

  z2'l = z2l;
  z3'r = z3r;

  z3'l = z2l + whatever * dir 15;
  z2'r = z3r + whatever * dir 15;

  z2r - z2l = 3/2rule_thickness * dir 15;
  z3r - z3l = 2rule_thickness * dir 15;
  z3'l = z3r + rule_thickness * dir (angle (z4r - z3r));

  z1l - z2l = whatever * (z4r - z3r);
  z2'r = whatever[z1l,z2l];

  fill stroke z1e -- z2e -- z2'e -- z3'e -- z3e -- z4e;

  pickup rule_pen;

  draw arrowhead(z4, angle (z4l - z3l), 4/5arrow_spread);

  penlabels(1,2,2',3',3,4);
endchar;

beginsymbol(11u#, 1/2[x_height#,asc_height#], 0)
  "diamond suit";

  x0 = x2 = w/2;
  1/2[y0,y2] = h/2;
  y2 - y0 = h;

  1/2[x1,x3] = w/2;
  x3 - x1 = w - 2side_bearing;
  y1 = y3 = h/2;

  pickup pencircle scaled rule_thickness;

  draw z0{dir (90+30)} .. {dir (180-30)}z1{dir (0+30)}
                       .. {dir (90-30)}z2{dir (270+30)}
                       .. {dir (0-30)}z3{dir (180+30)}
                       .. {dir (270-30)}z0 & cycle;
endchar;

beginsymbol(11u#, 1/2[x_height#,asc_height#], 0)
  "heart suit";

  x0 = x1 = w/2;
  y0 = 0;

  1/2[x2,x3] = w/2;
  x3 - x2 = w - 2side_bearing;

  y1 = y2 = y3;

  x4 = 1/2[x1,x2];
  x5 = 1/2[x1,x3];

  y4 = y5 = h;

  h - y1 = x4 - x2;

  pickup pencircle scaled rule_thickness;

  draw z0{dir (90+20)} .. z2 .. z4 .. {dir (270+20)}z1{dir (90-20)} .. z5 .. z3 .. {dir (270-20)}z0 & cycle;
endchar;

beginsymbol(11u#, 1/2[x_height#,asc_height#], 0)
  "spade suit";

  x0 = x1 = w/2;
  y0 = h + 1/2rule_thickness;

  1/2[x2,x3] = w/2;
  x3 - x2 = w - 2side_bearing;

  y2 = y3;

  x4 = 1/2[x1,x2];
  x5 = 1/2[x1,x3];

  y4 = y5 = 1/6h;

  y2 - y4 = x4 - x2;

  y1 = 1/3[y2,y4];

  x6 = x0;
  y6 = 0;
  penpos1(1/2rule_thickness, 0);
  penpos6(3/2rule_thickness, 0);

  pickup pencircle scaled rule_thickness;

  fill z0{dir (270-20)} .. z2 .. z4 .. {dir (90-20)}(z1 + 1/2rule_thickness*left)
    -- (z1 + 1/2rule_thickness*right){dir (270+20)} .. z5 .. z3 .. {dir (90+20)}z0 -- cycle;

  fill stroke z1e -- z6e;

  labels (0,1,2,3,4,5,6);
endchar;

beginsymbol(11u#, 1/2[x_height#,asc_height#], 0)
  "club suit";

  radius := 5/11(w - 4side_bearing);

  x0 = w/2;
  y0 = h - 2.5radius;

  x1 = w - x3 = 3/5x0;
  y1 = y3 = y0;
  x2 = x4 = x0;
  y2 = h - radius;
  y4 = 0;

  penpos0(2/3rule_thickness,  0);
  penpos1(2/3rule_thickness, 90);
  penpos2(2/3rule_thickness,  0);
  penpos3(2/3rule_thickness, 90);
  penpos4(3/2rule_thickness,  0);

  fill circle(z1, radius);
  fill circle(z2, radius);
  fill circle(z3, radius);

  fill stroke z2e -- z0e{down} .. z4e;
  fill stroke z1e -- z3e;

  labels (0,1,2,3,4);
endchar;

beginsymbol(5/4order_width# + 2side_bearing#, asc_height#, 0);
  "forall";
  pickup rule_pen;

  lft x0 = side_bearing;
  rt x1  = w - side_bearing;
  x2     = w/2;

  top y0 = top y1 = h;
  bot y2 = 0;

  z4 = whatever [z0,z2];
  z5 = whatever [z1,z2];

  y4 = y5 = x_height;

  draw z0 -- z2 -- z1;

  pickup pencircle scaled 8/9rule_thickness;

  draw z4 -- z5;
endchar;

for negated = 0, 1:
  beginsymbol(order_width# + 2side_bearing#,
              if negated = 0: asc_height# else: asc_height# + 2/3equal_spread# fi,
              if negated = 0: 0 else: 2/3equal_spread# fi);
    "exists";

    pickup rule_pen;

    lft x0 = lft x2 = side_bearing;
    rt x1  = rt x3  = w - side_bearing;

    top y0 = top y1 = asc_height;
    bot y2 = bot y3 = 0;

    z4 = 1/8[1/2[z0,z2], 1/2[z1,z3]];

    draw z0 -- z1 -- z3 -- z2;
    draw z4 -- 1/2[z1,z3];

    if negated = 1:
      stroke_through(1/2[1/2[z0,z2], 1/2[z1,z3]], h + d - stroke_through_thickness)
    fi;
  endchar;
endfor;

beginsymbol(3/2order_width# + 2side_bearing#, vcentre(med_op_size#)); "nabla";
  pickup pencircle scaled 2/3rule_thickness;

  top y0 = top y1 = h;
  bot y2 = -d;

  x0 = side_bearing;
  x1 = w - side_bearing;
  x2 = w/2;

  y3 = y4 = y0 - 2/3rule_thickness;

  z3 = whatever[z0,z2];
  z4 = whatever[z1,z2];
  z5 = whatever[z0,z1];
  z6 = whatever[z1,z2];

  x5 - x0 = -2/3rule_thickness / sind (angle (z2 - z0));

  z6 = z5 + whatever * (z2 - z0);

  draw z0 -- z1 -- z2 -- cycle;
  filldraw z0 -- z3 -- z4 -- z1 -- cycle;
  filldraw z0 -- z5 -- z6 -- z2 -- cycle;
endchar;

beginsymbol(2order_width# + 2side_bearing#, x_height#, 0); "infinity";
  pickup rule_pen;

  lft x0 = side_bearing;
  rt  x1 = w - side_bearing;

  top y2 = top y4 = h;
  bot y3 = bot y5 = d + rule_thickness;

  y0 = y1 = 1/2[y2,y3];

  x2 = x3 = 1/5[x0,x1];
  x4 = x5 = 4/5[x0,x1];

  penpos0 (rule_thickness, 180);
  penpos1 (rule_thickness, 180);
  penpos2 (3/2rule_thickness * cosd 30, 75);
  penpos5 (3/2rule_thickness * cosd 30, 75);
  penpos6 (3/2rule_thickness, 45);
  penpos7 (3/2rule_thickness, 45);
  penpos8 (3/2rule_thickness, 45);
  penpos9 (6/5rule_thickness, 135);
  penpos10(6/6rule_thickness, 135);

  z6 = 1/2[z0,z1];

  z7  = point 1/3 of (z2{right} .. {dir -45}z6);
  z8  = point 2/3 of (z6{dir -45} .. {right}z5);
  z9  = point 7/12 of (z0{up} .. {right}z2);
  z10 = point 5/12 of (z5{right} .. {up}z1);

  fill stroke z0e{up} .. {dir 45}z9e .. z2e{right} .. z7e
    .. {dir -45}z6e .. z8e .. {right}z5e .. {dir 45}z10e .. {up}z1e;

  draw z1{dir 90} .. z4{dir 180} .. {dir 225}z6{dir 225} .. {dir 180}z3{dir 180}
    .. {dir 90}z0;
  penlabels(0,1,2,3,4,5,6,7,8,9,10);
endchar;

beginsymbol(1/2order_width# + 2side_bearing#,
            asc_height# + 2/3rule_thickness#,
            2/3rule_thickness#);
  "small integral";

  pair centre;
  centre := (w/2, (h - d)/2);

  draw_integral([0])(1/2, centre);
endchar;

beginsymbol(order_width#, asc_height#, 0)
  "flat";

  x0 = x1 = x4 = side_bearing + rule_thickness;
  y0 = 0; y1 = h;
  x3 = w - side_bearing;

  y3 = 0.45[y0,y1];

  y4 = 4/5x_height;

  penpos0(rule_thickness, 10);
  penpos1(rule_thickness, 10);
  penpos3(rule_thickness, 0);

  fill stroke z0e -- z1e;

  pickup pencircle scaled rule_thickness;

  draw z0{dir 40} .. {up}z3 .. {dir 230}z4;

  penlabels (0,1,3,4);
  endchar;

beginsymbol(order_width#, asc_height#, 0)
  "natural";

  x0 = x1 = w - x2 = w - x3 = side_bearing + 1/2rule_thickness;
  x4 = x5 = w - x6 = w - x7 = side_bearing;

  y1 = y3 = h;
  y7 = x_height;
  y6l = 0;
  y0 = y2  = -h/3;

  z6 = z4 + whatever * dir 15;
  z5 = z7 + whatever * dir 15;

  z8 = whatever[z0,z1] = whatever[z4,z6];
  z9 = whatever[z2,z3] = whatever[z5,z7];

  x10 = x0l;
  x11 = x0l;
  x12 = x2r;
  x13 = x2r;

  z10 = whatever[z4,z6];
  z11 = whatever[z5,z7];
  z12 = whatever[z4,z6];
  z13 = whatever[z5,z7];

  penpos0(rule_thickness, 10);
  penpos1(rule_thickness, 10);
  penpos2(rule_thickness, 10);
  penpos3(rule_thickness, 10);
  penpos4(5/4rule_thickness, 90);
  penpos5(5/4rule_thickness, 90);
  penpos6(5/4rule_thickness, 90);
  penpos7(5/4rule_thickness, 90);
  penpos8 (rule_thickness, 10);
  penpos9 (rule_thickness, 10);
  penpos10(5/4rule_thickness, 90);
  penpos11(5/4rule_thickness, 90);
  penpos12(5/4rule_thickness, 90);
  penpos13(5/4rule_thickness, 90);

  fill stroke z1e -- z8e;
  fill stroke z9e -- z2e;
  fill stroke z10e -- z12e;
  fill stroke z11e -- z13e;

  penlabels (0,1,2,3,4,5,6,7);
  endchar;

beginsymbol(order_width#, asc_height#, 0)
  "sharp";

  x0 = x1 = w - x2 = w - x3 = side_bearing + rule_thickness;

  x4 = x5 = w - x6 = w - x7 = side_bearing;

  y3 = h;
  y7 = x_height;
  y6l = 0;
  y0  = -h/3;

  z2 = z0 + whatever * dir 20;
  z1 = z3 + whatever * dir 20;
  z6 = z4 + whatever * dir 15;
  z5 = z7 + whatever * dir 15;

  penpos0(rule_thickness, 10);
  penpos1(rule_thickness, 10);
  penpos2(rule_thickness, 10);
  penpos3(rule_thickness, 10);
  penpos4(5/4rule_thickness, 90);
  penpos5(5/4rule_thickness, 90);
  penpos6(5/4rule_thickness, 90);
  penpos7(5/4rule_thickness, 90);

  fill stroke z0e -- z1e;
  fill stroke z2e -- z3e;
  fill stroke z4e -- z6e;
  fill stroke z5e -- z7e;

  penlabels (0,1,2,3,4,5,6,7);
endchar;

beginsymbol(11u#, 0.85asc_height#, 0); "aleph";

  pickup pencircle scaled 2/3rule_thickness;

  penpos 1(0, 65);
  penpos 2(rule_thickness, 65);
  penpos 3(rule_thickness, 65);
  penpos 4(0, 65);
  penpos 5(rule_thickness, 65);
  penpos 6(rule_thickness, 65);
  penpos 7(rule_thickness, 65);
  penpos 8(rule_thickness, 65);
  penpos 9(rule_thickness, 65);
  penpos10(rule_thickness, 65);
  penpos11(rule_thickness, 65);
  penpos12(rule_thickness, 65);
  penpos13(rule_thickness, 65);

  x1l = side_bearing;
  x4r = w - side_bearing;
  y1r = h;
  y4l = 0;

  x2 - x1 = x4 - x3 = ceiling (u/2);
  y1 - y2 = y3 - y4 = 2rule_thickness;
  1/2[z2,z3] = (w/2,h/2);

  z5 = 0.24[z2,z3];
  z6 = 0.60[z2,z3];

  x7 = x8 = x2;
  x9 = x5;
  y7 = min (y6, y5 - 3/2rule_thickness);
  bot y8l = bot y9l = 0;

  x10 = x11 = 0.85[x2,x3];
  y10 = max (y5, y6 + 3/2rule_thickness);

  x12 = x3 + 2/3rule_thickness;
  x13 = 1/4[x6,x10];

  top y13r = h;
  z12 = z13 + whatever * (z3-z2);
  z11 = z13 + whatever * (z3-z2);

  y11r := y11;  % prevent the stroke from sticking out at the other side

  filldraw stroke z1e{down} ... {z3e-z2e}z2e -- z3e{z3e-z2e} ... {down}z4e;
  filldraw stroke z12e -- z13e;

  alpha := angle (z5 - z7);
  beta  := (alpha + 90)/2;
  penpos5'(3/2rule_thickness * abs cosd (155 - alpha), alpha - 90);
  penpos7'(3/2rule_thickness * abs cosd (155 - beta),  beta  - 90);
  z5' = z5;
  z7' = z7;

  % We don't need a filldraw since the stroke is that thin.
  % A filldraw might cause "Strange path" errors in low resolutions.

  draw stroke z5'e{-dir alpha} .. {-dir beta}z7'e -- z8e;
  filldraw stroke z8e -- z9e;

  alpha := angle (z10 - z6);
  beta := (alpha + 90)/2;
  penpos 6'(3/2rule_thickness * abs cosd (155 - alpha), alpha - 90);
  penpos10'(3/2rule_thickness * abs cosd (155 - beta),  beta  - 90);
  z6' = z6;
  z10' = z10;

  draw stroke z6'e{dir alpha} .. {dir beta}z10'e -- z11e;

  penlabels(1,2,3,4,5,6,7,8,9,10,11,12,13,5',7');
endchar;

beginsymbol(11u#, 0.85asc_height#, 0); "beth";

  pickup pencircle scaled 2/3rule_thickness;

  penpos1(0, 65);
  penpos2(rule_thickness, 65);
  penpos3(rule_thickness, 65);
  penpos4(rule_thickness, 65);
  penpos5(rule_thickness, 65);
  penpos6(rule_thickness, 65);
  penpos7(rule_thickness, 65);

  x1l = side_bearing + rule_thickness;
  y1r = h;
  x2 - x1 = ceiling (u/2);
  y1 - y2 = 3/2rule_thickness;
  y3 = y2;

  x3 = w - x2;
  bot y5l = 0;

  x4r = w - side_bearing;
  y3l - y4 = y1 - y2r;

  x5 = x4;

  x6 = w - x7l = side_bearing;
  y6 = y7 = y5;

  filldraw stroke z1e{down} ... {z3e-z2e}z2e -- z3e{z3e-z2e} ... {down}z4e -- z5e;
  filldraw stroke z6e -- z7e;

  penlabels(1,2,3,4,5,6,7);
endchar;

beginsymbol(7u#, 0.85asc_height#, 0); "gimel";

  pickup pencircle scaled 2/3rule_thickness;

  penpos1(0, 65);
  penpos2(rule_thickness, 65);
  penpos3(rule_thickness, 65);
  penpos4(rule_thickness, 65);
  penpos5(rule_thickness, 65);
  penpos6(rule_thickness, 65);
  penpos7(rule_thickness, 65);
  penpos8(rule_thickness, 65);

  x1l = side_bearing + rule_thickness;
  y1r = h;
  x2 - x1 = ceiling (u/2);
  y1 - y2 = 3/2rule_thickness;

  z3 = z2 + whatever * dir -25;

  x3 = w - x2;

  x4r = w - side_bearing - 1/3rule_thickness;
  y3l - y4 = y1 - y2r;

  x5 = x4;
  x6 = w - side_bearing;

  y5l = y8r;
  bot y6l = 0;

  x7 = side_bearing;
  rt x8r = lft x5l;
  y7 = y8 = y6;

  filldraw stroke z1e{down} ... {z3e-z2e}z2e -- z3e{z3e-z2e} ... {down}z4e -- z5e .. z6e;
  filldraw stroke z7e -- z8e;

  penlabels(1,2,3,4,5,6,7,8);
endchar;

beginsymbol(11u#, 0.85asc_height#, 0); "daleth";

  pickup pencircle scaled 2/3rule_thickness;

  penpos1(0, 65);
  penpos2(rule_thickness, 65);
  penpos3(rule_thickness, 65);
  penpos4(1/2rule_thickness, 65);
  penpos5(rule_thickness, 65);

  x1l = side_bearing;
  y1r = h;
  x2 - x1 = ceiling (u/2);
  y1 - y2 = 3/2rule_thickness;
  y2 = y3 = y4;

  x3 = w - side_bearing;
  x4 = x3 - 3/2rule_thickness;
  y5 = 0;
  x5l = x4l;


  filldraw stroke z1e{down} ... {z3e-z2e}z2e -- z3e{z3e-z2e};
  filldraw stroke z4e{down} ... z5e;

  penlabels(1,2,3,4,5);
endchar;


begingroup;

save slant;
save currenttransform;

slant := 0.212557;

transform currenttransform;

currenttransform := identity slanted slant yscaled aspect_ratio scaled granularity shifted (-u,0);

beginsymbol(11u#, x_height#, 8/25asc_height#);
  "Weierstrass p";

  pickup pencircle scaled 1/2rule_thickness;

  numeric theta;
  theta = 90-angle(8u,h);
  slope := -h/8u;  % angle at middle
  superness := 1/sqrt 2;
  superpull := 1/6;

  penpos2(1/2rule_thickness, -90);
  penpos1(5/6rule_thickness,theta);
  penpos7(1/2rule_thickness, -90);

  x2 + .5u = x1 = x7 - .5u = 3u;
  top y2l = h;
  bot y7r = -d;
  y1 = .4[-d, h];

  lft x3l = hround .5u;
  rt  x6r = hround max(rt x7 + .5, .5w - .25u);

  x3r - x3l = x6r - x6l = (hround 3/4rule_thickness) - 1/10rule_thickness;

  ellipse_set(2l,3l,4l,1l);
  ellipse_set(2r,3r,4r,1r);
  ellipse_set(7l,6l,5l,1l);
  ellipse_set(7r,6r,5r,1r);

  y3 = y3r;
  y6 = y6r;

  filldraw stroke super_arc.e(2,3) & z3e{down} .. z4e --- z5e .. z6e{down} & super_arc.e(6,7);  % flourish

  penpos8(1/2rule_thickness, 180);
  penpos9(1/2rule_thickness, 90);
  penpos10(rule_thickness, 0);
  penpos11(1/2rule_thickness, -90);
  penpos12(1/2rule_thickness, -180);
  penpos13(5/7rule_thickness, -180);

  rt  x10r = hround(w - 1.5u + 1/2rule_thickness);
  lft x12r = hround(.5w - .5u);
  rt  x8l  = hround 2.25u;
  x9 = x11 = max(x12l + eps, .5w + 1.5u);
  y8 = 0;
  top y9r = vround .95h;
  y10 = .5[y9,y11];
  bot y11r = y8;

  filldraw stroke z7e{left} ... z8e{up} ... pulled_arc.e(9,10) & pulled_arc.e(10,11);  % stem and bowl

  y13 - 5/7rule_thickness = .15h;
  bulb(11,12,13);  % bulb

  penlabels(1,2,3,4,5,6,7,8,9,10,11,12,13);
endchar;

beginsymbol(11u#, 11/10asc_height#, 1/10asc_height#);
  "powerset";

  pickup pencircle scaled 1/2rule_thickness;

  numeric theta;
  theta = 90 - angle(12/7*8u, h);
  slope := -h/(12/7*8u);  % angle at middle
  superness := 1/sqrt 2;
  superpull := 1/6;

  penpos2(1/2rule_thickness, -90);
  penpos1(rule_thickness,theta);
  penpos7(1/2rule_thickness, -90);

  x2 + .5u = x1 = x7 - .5u = 3u;
  top y2l = h;
  bot y7r = -d;
  y1 = .4h;

  lft x3l = hround .5u;
  rt  x6r = hround max(rt x7 + .5, .5w - .25u);

  x3r - x3l = x6r - x6l = (hround 3/4rule_thickness) - 1/10rule_thickness;

  ellipse_set(2l,3l,4l,1l);
  ellipse_set(2r,3r,4r,1r);
  ellipse_set(7l,6l,5l,1l);
  ellipse_set(7r,6r,5r,1r);

  y3 = y3r;
  y6 = y6r;

  filldraw stroke super_arc.e(2,3) & z3e{down} .. z4e --- z5e .. z6e{down} & super_arc.e(6,7);  % flourish

  penpos8(1/2rule_thickness, 180);
  penpos9(1/2rule_thickness, 90);
  penpos10(rule_thickness, 0);
  penpos11(1/2rule_thickness, -90);
  penpos12(1/2rule_thickness, -180);
  penpos13(5/7rule_thickness, -180);

  rt  x10r = hround(w - 1.5u + 1/2rule_thickness);
  lft x12r = hround(.5w - .5u);
  rt  x8l  = hround 2.25u;
  x9 = x11 = max(x12l + eps, .5w + 1.5u);
  y8 = 10/11*5/12h;
  top y9r = vround .95h;
  y10 = .5[y9,y11];
  bot y11r = y8;

  filldraw stroke z7e{left} ... z8e{up} ... pulled_arc.e(9,10) & pulled_arc.e(10,11);  % stem and bowl

  y13 - 5/7rule_thickness = y8 + 1/10h;
  bulb(11,12,13);  % bulb

  penlabels(1,2,3,4,5,6,7,8,9,10,11,12,13);
endchar;

endgroup;

% Warning: The other two orientations are above.
% They should stay consistent.

beginoperator(plus_size#, 1); "upside down logical not";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 180) -- (centre + r * dir 0)
                              -- (centre + r * dir 0 + equal_spread * dir 90);
endchar;

beginoperator(plus_size#, 1); "upside down reversed logical not";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 180 + equal_spread * dir 90)
    -- (centre + r * dir 180) -- (centre + r * dir 0)
endchar;

for sign = 1, -1:
  beginoperator(plus_size#, 1); "half square union";
    pickup rule_pen;

    z3 - z0 = z2 - z1 = plus_size * dir 0;
    z0 - z1 = sign * plus_size * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z0 -- z1 -- z2;
  endchar;

  beginoperator(plus_size#, 1); "half square union";
    pickup rule_pen;

    z3 - z0 = z2 - z1 = plus_size * dir 0;
    z0 - z1 = sign * plus_size * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z1 -- z2 -- z3;
  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(plus_size#, 1); "closed curly wedge";
    pickup rule_pen;

    z0 = centre + 1/2plus_size * dir alpha;
    z1 = centre - 1/2plus_size * dir alpha;
    z2 = z1 + 1/2plus_size * dir (alpha + 90);
    z3 = z1 - 1/2plus_size * dir (alpha + 90);

    draw z2{dir (alpha - 40)}
      .. {dir alpha}z0{dir (alpha + 180)}
      .. {dir (alpha - 140)}z3{dir (alpha + 40)}
      .. {dir (alpha + 140)}z2 & cycle;

  endchar;
endfor;

for alpha = 0, 90, 180, 270:
  beginoperator(6/5plus_size#, 1); "slice";
    pickup rule_pen;

    z1 - 1/2[z0,z2] = plus_size * dir alpha;

    z2 - z0 = plus_size * dir (alpha + 90);

    7/12[z1,1/2[z0,z2]] = centre;

    draw z1 -- z0{dir (alpha + 120)} .. {dir (alpha + 60)}z2 -- cycle;
  endchar;
endfor;

beginoperator(5/6small_op_size#, 8/5); "small lozenge";
  pickup rule_pen;

  lft x0 = w - rt x2 = side_bearing;
  y0 = y2 = ypart centre;

  x1 = x3 = xpart centre;
  top y1 = h;
  bot y3 = -d;

  draw z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

beginoperator(5/6small_op_size#, 8/5); "small filled lozenge";
  pickup rule_pen;

  lft x0 = w - rt x2 = side_bearing;
  y0 = y2 = ypart centre;

  x1 = x3 = xpart centre;
  top y1 = h;
  bot y3 = -d;

  draw z0 -- z1 -- z2 -- z3 -- cycle;
  fill z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

beginoperator(1/sqrt(2)*med_op_size#, 8/5); "medium lozenge";
  pickup rule_pen;

  lft x0 = w - rt x2 = side_bearing;
  y0 = y2 = ypart centre;

  x1 = x3 = xpart centre;
  top y1 = h;
  bot y3 = -d;

  draw z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

beginoperator(1/sqrt(2)*med_op_size#, 8/5); "medium filled lozenge";
  pickup rule_pen;

  lft x0 = w - rt x2 = side_bearing;
  y0 = y2 = ypart centre;

  x1 = x3 = xpart centre;
  top y1 = h;
  bot y3 = -d;

  draw z0 -- z1 -- z2 -- z3 -- cycle;
  fill z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

beginoperator(1/sqrt(2)*large_op_size#, 8/5); "large lozenge";
  pickup rule_pen;

  lft x0 = w - rt x2 = side_bearing;
  y0 = y2 = ypart centre;

  x1 = x3 = xpart centre;
  top y1 = h;
  bot y3 = -d;

  draw z0 -- z1 -- z2 -- z3 -- cycle;
endchar;

for alpha = 0, 90, 180, 270:
  beginoperator(med_op_size#, 1); "medium filled triangle (" & decimal alpha & ")";
    pickup rule_pen;
    draw triangle(centre, w/2-side_bearing, alpha);
    fill triangle(centre, w/2-side_bearing, alpha);
  endchar;
endfor;

beginoperator(med_op_size#/sqrt(2), 1); "medium filled square";
  pickup rule_pen;
  draw square(centre, w/2 - side_bearing, 0);
  fill square(centre, w/2 - side_bearing, 0);
endchar;


beginoperator(large_op_size#, 1); "large filled star";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(5, centre, r, 90);
  reg_poly_points(b)(5, centre, .4r, 126);
  draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
  fill z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
endchar;

beginoperator(med_op_size#, 1); "medium star of david";
  pickup pencircle scaled 4/5rule_thickness;
  r := w/2 - side_bearing;
  reg_poly_points(a)(6, centre, r, 90);
  draw z.a0 -- z.a2 -- z.a4 -- cycle;
  draw z.a1 -- z.a3 -- z.a5 -- cycle;
endchar;

beginoperator(large_op_size#, 1); "large star of david";
  pickup rule_pen;
  r := w/2 - side_bearing;
  reg_poly_points(a)(6, centre, r, 90);
  draw z.a0 -- z.a2 -- z.a4 -- cycle;
  draw z.a1 -- z.a3 -- z.a5 -- cycle;
endchar;

beginoperator(med_op_size#, 1); "maltese";
  pickup rule_pen;

  1/2[z0,z1] = centre + 1/2med_op_size * dir 180;
  1/2[z2,z3] = centre + 1/2med_op_size * dir 270;
  1/2[z4,z5] = centre + 1/2med_op_size * dir 0;
  1/2[z6,z7] = centre + 1/2med_op_size * dir 90;

  z0 - z1 = z5 - z4 = 1/2med_op_size * up;
  z3 - z2 = z6 - z7 = 1/2med_op_size * right;

  filldraw z1{dir 45}
    .. {right}centre{down}
    .. {dir 225}z2 -- z3{dir 135}
    .. {up}centre{right}
    .. {dir -45}z4 -- z5{dir 225}
    .. {left}centre{up}
    .. {dir 45}z6 -- z7{dir -45}
    .. {down}centre{left}
    .. z0{dir 135} -- cycle;
endchar;


current_char := 219;

% Keep these consistent with the glyphs in Sym-Order.mf!

for negated = 0, 1:

  vardef ifneg(text values) =
    select(negated)(values)
  enddef;

  beginorder(1, order_width# + rule_thickness#, ifneg(2,4) * equal_spread# + rule_thickness#);
    "closedequal";
    pickup rule_pen;

    z2 - z1 = z1 - z0 = equal_spread * dir 90;
    z5 - z4 = z4 - z3 = equal_spread * dir 90;

    1/2[z0, z2] = left_point;
    1/2[z3, z5] = right_point;

    draw z0 -- z3;
    draw z1 -- z4 -- z5 -- z2 -- cycle;

    if negated = 1:
      stroke_through(centre, 4equal_spread);
    fi;
  endchar;

  beginorder(1, order_width# + rule_thickness#, ifneg(2,4) * equal_spread# + rule_thickness#);
    "equalclosed";
    pickup rule_pen;

    z2 - z1 = z1 - z0 = equal_spread * dir 90;
    z5 - z4 = z4 - z3 = equal_spread * dir 90;

    1/2[z0, z2] = left_point;
    1/2[z3, z5] = right_point;

    draw z0 -- z3 -- z4 -- z1 -- cycle;
    draw z2 -- z5;

    if negated = 1:
      stroke_through(centre, 4equal_spread);
    fi;
  endchar;

  beginorder(1, order_width# + rule_thickness#, ifneg(2,4) * equal_spread# + rule_thickness#);
    "equivclosed";
    pickup rule_pen;

    z2 - z1 = z1 - z0 = equal_spread * dir 90;
    z5 - z4 = z4 - z3 = equal_spread * dir 90;

    1/2[z0, z2] = left_point;
    1/2[z3, z5] = right_point;

    draw z0 -- z3 -- z5 -- z2 -- cycle;
    draw (z1 + 1/4rule_thickness * right) -- (z4 + 1/4rule_thickness * left);

    if negated = 1:
      stroke_through(centre, 4equal_spread);
    fi;
  endchar;

  for sign = 1, -1:
    beginorder(sign, order_width# + rule_thickness#,
                     greater_spread# + ifneg(4/3, 8/3) * equal_spread# + rule_thickness#);
      "less sim";

      pickup rule_pen;

      z1 - z0 = greater_spread * dir 90;
      y2 = 1/2[y0, y1];
      x0 = xpart right_point;
      x2 = xpart left_point;
      y3 = y4 = y0 - equal_spread;
      x4 - x3 = sign * (x0 - x2);
      1/2[x3,x4] = xpart centre;

      1/2[y1, y4 - 1/3equal_spread] = ypart centre;

      draw z0 -- z2 -- z1;
      draw sim(z3, z4);

      if negated = 1:
        stroke_through(centre, 8/3equal_spread + greater_spread);
      fi;
    endchar;
  endfor;

  for sign = 1, -1:
    beginorder(sign, order_width# + rule_thickness#,
                     greater_spread# + ifneg(7/3, 9/3) * equal_spread# + rule_thickness#);
      "less approx";

      pickup rule_pen;

      z1 - z0 = greater_spread * dir 90;
      y2 = 1/2[y0, y1];
      x0 = xpart right_point;
      x2 = xpart left_point;
      y3 = y4 = y0 - equal_spread;
      y5 = y6 = y4 - equal_spread;
      x4 - x3 = sign * (x0 - x2);
      1/2[x3,x4] = xpart centre;
      x6 = x4;
      x5 = x3;

      1/2[y1, y6 - 1/3equal_spread] = ypart centre;

      draw z0 -- z2 -- z1;
      draw sim(z3, z4);
      draw sim(z5, z6);

      if negated = 1:
        stroke_through(centre, 9/3equal_spread + greater_spread);
      fi;
    endchar;
  endfor;

  for sign = 1, -1:
    beginorder(sign, order_width# + rule_thickness#,
      greater_spread# + ifneg(1,3) * equal_spread# + rule_thickness#);
      "slanted equal or less than";

      pickup rule_pen;

      z0 - z1 = greater_spread * dir 90;
      z3 - z2 = equal_spread * dir 90;
      z4 - z0 = equal_spread * dir 90;

      1/2[z2, z3] = left_point;
      1/2[z1, z4] = right_point;

      draw z0 -- z2 -- z1;
      draw z3 -- z4;

      if negated = 1:
        stroke_through(centre, 3equal_spread + greater_spread);
      fi;
    endchar;
  endfor;

  for sign = 1, -1:
    beginorder(sign, order_width# + rule_thickness#,
               ifneg(1,3) * equal_spread# + 2/3[equal_spread#, greater_spread#] + rule_thickness#);
      "curly equal or curly less than";

      pickup rule_pen;

      t := 2/3[equal_spread, greater_spread];

      z0 - z1 = equal_spread * dir 90;
      z2 - z4 = 7/5equal_spread * dir 90;
      z4 - z3 = t/2 * dir 90;
      y1 = y3;
      y4 = ypart centre + 1/2(t - equal_spread);
      x0 = xpart left_point;
      x2 = xpart right_point;

      path p;

      p = z0{z3 - z1} .. z2;

      v := xpart (p intersectiontimes (z4 -- (z4 + h * dir (90 + sign * 20))));

      draw prec(z1, z3, t);
      draw subpath (0,v) of p;

      if negated = 1:
        stroke_through(centre, 3equal_spread + 2/3[equal_spread, greater_spread]);
      fi;

      labels(0,1,2,3,4);
    endchar;
  endfor;

  for alpha = 0, 180:
    beginarrow(alpha, 6/5, ifneg(14/10, 21/10) * arrow_spread#); "triple arrow (" & decimal alpha & ")";

      z1 - z0 = z2 - z1 = z4 - z3 = z5 - z4 = 2/3equal_spread * dir (arrow_dir + 90);

      z1 = foot;
      z4 = head;

      pickup pencircle scaled 4/5rule_thickness;

      draw z0 -- arrowhead_intersection(head, arrow_dir, 14/10arrow_spread, z0 -- z3);
      draw z1 -- arrowhead_intersection(head, arrow_dir, 14/10arrow_spread, z1 -- z4);
      draw z2 -- arrowhead_intersection(head, arrow_dir, 14/10arrow_spread, z2 -- z5);

      pickup rule_pen;

      draw arrowhead(head, arrow_dir, 14/10arrow_spread);

      if negated = 1:
        stroke_through_arrow(1/2[foot, head - arrow_spread * dir arrow_dir], alpha, 21/10arrow_spread)
                            (70, 70, 110, 110, 70, 70, 110, 110);
      fi
    endchar;
  endfor;

endfor;

for sign = -1, 1:
  beginsymbol(4/3arrow_spread# + 2side_bearing#, vcentre(2arrow_spread# + rule_thickness#));
    "left shift";

    pickup rule_pen;

    top y0 = top y1 = h - 1/2arrow_spread;
    bot y2 = -d;

    1/2[x0,x1] = w/2;
    x1 - x0 = sign * 4/3arrow_spread;

    x2 = x1;

    draw z0 -- z1 -- z2;

    draw arrowhead(z0, 90 + sign * 90, arrow_spread);
  endchar;
endfor;

for sign = -1, 1:
  beginoperator(arrow_len#, 1);
    "loop arrow";

    pickup rule_pen;

    z0 = centre + sign * arrow_len/2 * left;
    z1 = centre + arrow_len/2 * down;
    z2 = centre + arrow_len/4 * up;
    z3 = centre + sign * arrow_len/4 * right;
    z4 = centre + arrow_len * (1/4sign, 1/2);
    z5 = centre + arrow_len * (1/2sign, 1/4);

    draw z0 -- z3{sign * right} .. {up}z5 .. {sign * left}z4 .. {down}z2 -- z1;

    draw arrowhead(z0, 90 + sign * 90, arrow_spread);
  endchar;
endfor;

for sign = -1, 1:
  beginoperator(plus_size#, 1); "three times";
    pickup rule_pen;

    r := plus_size/2;
    r := r * 1/3[1, sqrt 2];

    z0 = centre + r * dir (sign * 45);
    z1 = centre + r * dir (sign * 225);
    z2 = centre + r * dir (270 + sign * 45);
    z3 = centre + 1/4rule_thickness * dir (270 + sign * 45);

    draw z0 -- z1;
    draw z3 -- z2;
  endchar;
endfor;

beginarrow(0, 5/6, 7/4arrow_spread#);
  "Vvdash";

  pickup rule_pen;

  z0 = foot + 4/5equal_spread * dir arrow_dir;
  z1 = foot + 8/5equal_spread * dir arrow_dir;

  draw z1 + 1/4rule_thickness * dir arrow_dir -- head;
  draw (foot - 7/8arrow_spread * dir (arrow_dir + 90)) --
       (foot + 7/8arrow_spread * dir (arrow_dir + 90));
  draw (z0   - 7/8arrow_spread * dir (arrow_dir + 90)) --
       (z0   + 7/8arrow_spread * dir (arrow_dir + 90));
  draw (z1   - 7/8arrow_spread * dir (arrow_dir + 90)) --
       (z1   + 7/8arrow_spread * dir (arrow_dir + 90));

endchar;

beginoperator(plus_size#, 1); "negated medium bar";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  draw (centre + r * dir 90) -- (centre + r * dir 270);

  stroke_through_arrow(centre, 90, 2/3plus_size, 45);
endchar;

beginoperator(plus_size#, 1); "double bar";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  z1 - z0 = equal_spread * right;
  1/2[z0,z1] = centre;

  draw (z0 + r * up) -- (z0 + r * down);
  draw (z1 + r * up) -- (z1 + r * down);
endchar;

beginoperator(plus_size#, 1); "negated double bar";
  pickup rule_pen;

  r := plus_size/2; % - 11/10rule_thickness;

  z1 - z0 = equal_spread * right;
  1/2[z0,z1] = centre;

  draw (z0 + r * up) -- (z0 + r * down);
  draw (z1 + r * up) -- (z1 + r * down);

  stroke_through_arrow(centre, 90, plus_size, 40);
endchar;

